In order:

* BEFORE ADVERTISING IT TO THE PUBLIC:
** move all initialization code in modules into functions
   (that is for code like downloading currency data)
*** not for stuff that is needed, like monkey-patching pint for sympy
*** this includes:
**** psciclib.paths: create cache/preference/... directories
**** psciclib.units: download and parse currency data
** call that code when starting the UI (and when running tests,
   although with download disabled!)
** make the currency download optional and ask the user (data
   protection and privacy reasons)
*** ship a .xml file, so that the currency at least exists?
** the above needs a config file and preference dialog

* license [done]
** some about dialog and "licence" command which outputs all
   licences of dependencies, too

* support functions
** write tests!!!!
** also "negative" tests, where we expect failure
** multiple arguments
*** parsing [done]
*** validating (how many args does this func take?)
*** evaluating (easy?)

* SYMPY may be the solution to a lot of stuff, it uses mpmath and can be exact.
  Just need to get it to play nice with pint
** mostly DONE
** need to control output (i.e. exact vs float; float precision; ...)
** remove trailing zeros from floats on output
** DOES NOT YET PLAY NICE WITH UNITS! sympy unit support is not up to
   scratch with regard to pint, so we need to hammer those together
   ourselves!
*** solving equalities with units is not icky. often the solution
    seems OK, but is not evaluated!
*** Also missing: unit conversion for solutions.
** assumptions for x would be nice!
** using <expr>.atoms(sympy.Symbol), we can find all variables in an
   expression. This may be of some use for the solver/plotter, e.g.,
   if both x and y are in there, plot 3D.

* support constants (a bunch of letters instead of numbers)
** physical constants are still missing
** write tests!

* support units [should work in general, see below]
** temperature (non-K) may be harder to get right in a nice way
   (semantics are not always clear).
*** make °C / °F special syntax that immediately converts to kelvin
*** write a warning, because the semantics of 12°C+1°C are not clear!
*** make extra units (degC/degF) that are temperature differences and
    are converted to ΔK (no offset); also warn about this because it is
    not intuitive!
*** The warning stuff can be implemented by passing a "Hint" object around
    when evaluating the expression. The return value will then be a tuple
    of the actual results plus some informational data that can be displayed
    to the user
** Parse multiplied units like Js = J*s; this may be ambiguous! Be careful!
** get a list of all supported unit strings: ureg._units.keys()
** some short units are bad special case them: 
*** h is planck, not hour
*** pt is pint not point
*** ...

* a ° postfix operator, which converts to radians

* support plots

* GUI
** Add a hint field that will tell you something about the result if it is
   unexpected:
*** a result of "zoo" should hint: Complex Infinity, most likely your
    expression is undefined (division by zero etc.)
*** Perhaps one can force sympy to raise exceptions instead, which would be
    better (hint panel is still a good idea)
** a panel which shows stored custom variables for the session (also one
   should have the ability to define their own variables/functions)
** a unit/constant/function/symbol selector (instead of a keypad-thingy)
** document every function, unit, symbol, variable and (optionally) show
   this somewhere.

* support variables (x,y,z only perhaps?) [sympy does all the work]
** calculate everything except them [sympy]
** really useful when introducing the = sign, to solve a Dreisatz etc.
*** needs to auto-solve for equalities (and inequalities) [equalities done]
** auto-plot?

* matrices/vectors
** parsing is done
** sympy can handle it
** but: there are no vectors, only row matrices
   this is not user-friendly, as we need to transpose those sometimes
   so: auto-transpose them on evaluation!
** needs more support and error checking

* test:
** fuzzer: create random valid and invalid expression en masse and try to parse/evaluate
   them

* hex/oct/bin input/output.  support floats.  [input done]
** support roman numerals somehow  [input done]
