In order:

* The parser should already spit out custom objects instead of lists/tuples,
  that way pretty-printing is easy, too (some example code does it like this, the boolean
  logic parser, perhaps?)

* support functions
** bunch of letters followed by open paranthesis
** may be implemented as a special kind of opening parenthesis

* support constants (a bunch of letters instead of numbers)
** e, pi, physical constants, ...
** if a constant follows a number or ), the multiplication sign may be left out;
   in contrast to qalculate the sign is needed if the constant is in front of
   the number (this makes both 2e = 2*e and 2e3 = 2*10^3 unambiguously defined)

* support variables (x,y,z only perhaps?)
** calculate everything except them
** really useful when introducing the = sign, to solve a Dreisatz etc.

* support units
** this is the meat of the matter
** may be hard to parse
** it is easy, as pint uses them like this:

         12.0 * ureg.meter -> <Quantity(12.0, 'meter')>

   allowing us to treat units like constants! Nice!
** temperature (non-K) may be harder to get right in a nice way
   (semantics are not always clear).

* a Â° postfix operator, which converts to radians

* support unit conversion ("to" keyword like qalculate)

* support plots

* GUI

* other fancy stuff?
** sympy for symbolic calculations?
