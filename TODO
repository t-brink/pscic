In order:

* BEFORE ADVERTISING IT TO THE PUBLIC:
** move all initialization code in modules into functions
   (that is for code like downloading currency data)
*** not for stuff that is needed, like monkey-patching pint for sympy
*** this includes:
**** psciclib.paths: create cache/preference/... directories
**** psciclib.units: download and parse currency data
** call that code when starting the UI (and when running tests,
   although with download disabled!)
** make the currency download optional and ask the user (data
   protection and privacy reasons)
*** ship a .xml file, so that the currency at least exists?
** the above needs a config file and preference dialog

* license [done]
** some about dialog and "licence" command which outputs all
   licences of dependencies, too

* Roman numerals:
** perhaps do not give an error if impossible to convert, but just
   leave at default output...
** nicer literals for roman numerals
*** r{IV} / roman{MMLXI}
*** can't think of something nicer and it works for other weird input
    formats, too. Can also do 0xFF = x{FF}, 0o455 = o{455}, and
    0b1001 = b{1001} then (although the 0xFF thing stays canonical).

* improve startup time:
  https://files.bemusement.org/talks/OSDC2008-FastPython/

* support functions
** write tests!!!!
** also "negative" tests, where we expect failure
** multiple arguments
*** parsing [done]
*** validating (how many args does this func take?)
*** evaluating (easy?)

* SYMPY may be the solution to a lot of stuff, it uses mpmath and can be exact.
  Just need to get it to play nice with pint
** mostly DONE
** need to control output (i.e. exact vs float; float precision; ...)
** remove trailing zeros from floats on output
** DOES NOT YET PLAY NICE WITH UNITS! sympy unit support is not up to
   scratch with regard to pint, so we need to hammer those together
   ourselves!
*** solving equalities with units is not icky. often the solution
    seems OK, but is not evaluated!
*** Also missing: unit conversion for solutions.
** assumptions for x would be nice!
** using <expr>.atoms(sympy.Symbol), we can find all variables in an
   expression. This may be of some use for the solver/plotter, e.g.,
   if both x and y are in there, plot 3D.
** float-precision on parsing should match what the user put in! No
   loss until pretty-printing!
*** this works, but the precision should be at least equal to what is
    requested in the output! Better higher!
*** for a (not-so-nice, but workable) solution, see
    operators.process_float's TODO comment!
*** float-precision doesn't work nicely with pint which uses python
    floats  :-( No idea yet on how to fix this :-( Need to make a
    string roundtrip when dealing with this, perhaps a sympy.Float
    subclass can help
*** !!! In the end, all floats need the same precision when doing
    calculations !!! The test-suite must then be adapted to check
    for _exact_ float equality in the cases where we can require
    it (negation; noops, like the unary +; addition?; ...)

* support constants (a bunch of letters instead of numbers)
** physical constants are still missing
** write tests!

* support units [should work in general, see below]
** temperature (non-K) may be harder to get right in a nice way
   (semantics are not always clear).
*** make °C / °F special syntax that immediately converts to kelvin
*** write a warning, because the semantics of 12°C+1°C are not clear!
*** make extra units (degC/degF) that are temperature differences and
    are converted to ΔK (no offset); also warn about this because it is
    not intuitive!
*** The warning stuff can be implemented by passing a "Hint" object around
    when evaluating the expression. The return value will then be a tuple
    of the actual results plus some informational data that can be displayed
    to the user
** Parse multiplied units like Js = J*s; this may be ambiguous! Be careful!
** get a list of all supported unit strings: ureg._units.keys()
** some short units are bad special case them: 
*** h is planck, not hour
*** pt is pint not point
*** ...
** optionally(?) auto-apply prefixes (1200m -> 1.2km)
** 12 km/m does not yet give 12000 and 1 in/cm does not auto-resolve
   to dimensionless
** a "time" output format (besides scientific, engineering, ...) which
   will use prefixes for values smaller than 1s, otherwise it will use
   HH:MM:SS.ss for times < 24h.
   At times greater 24h it will prepend the number of days, weeks+days,
   years+weeks+days. (think if months make sense, but they are so
   ill-defined) years will be 365 days in this format to make nice even
   numbers.
*** maybe also parse something like that as input.
** In the end, the precision for pint (64bit float) is not satisfactory,
   and rolling my own unit support is probably preferable in the long run.
   At least that gives full control.
** units that are words should have plurals. limitation of pint: it
   parses, e.g., "2 days" but outputs "2 day".

* a ° postfix operator, which converts to radians

* support plots

* GUI
** Add a hint field that will tell you something about the result if it is
   unexpected:
*** a result of "zoo" should hint: Complex Infinity, most likely your
    expression is undefined (division by zero etc.)
*** Perhaps one can force sympy to raise exceptions instead, which would be
    better (hint panel is still a good idea)
** a panel which shows stored custom variables for the session (also one
   should have the ability to define their own variables/functions)
** a unit/constant/function/symbol selector (instead of a keypad-thingy)
** document every function, unit, symbol, variable and (optionally) show
   this somewhere.
** Math printing should be done with QWebKit + MathJax (local
   copy). Hopefully this is fast enough, otherwise we need to get tricky!
** pretty-printer doesn't set intelligent parentheses, this should be done!
** to best units / to base units  should be toggle-buttons (mutually
   exclusive!)

* support variables (x,y,z only perhaps?) [sympy does all the work]
** calculate everything except them [sympy]
** really useful when introducing the = sign, to solve a Dreisatz etc.
*** needs to auto-solve for equalities (and inequalities) [equalities done]
** auto-plot?

* matrices/vectors
** parsing is done
** sympy can handle it
** but: there are no vectors, only row matrices
   this is not user-friendly, as we need to transpose those sometimes
   so: auto-transpose them on evaluation!
** needs more support and error checking

* parser
** accept ²,³,⁴, etc. as ^2 ^3 ^4 etc.

* test:
** fuzzer: create random valid and invalid expression en masse and try to parse/evaluate
   them
